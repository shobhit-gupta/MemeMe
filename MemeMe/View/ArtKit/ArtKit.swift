//
//  ArtKit.swift
//  MemeMe
//
//  Created by Shobhit Gupta on 09/04/17.
//  Copyright © 2017 Shobhit Gupta. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class ArtKit : NSObject {

    //// Cache

    private struct Cache {
        static let white: UIColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        static let secondaryColor: UIColor = ArtKit.white
        static let shadowOfSecondaryColor: UIColor = ArtKit.secondaryColor.shadow(withLevel: 0.3)
        static let highlightOfSecondaryColor: UIColor = ArtKit.secondaryColor.highlight(withLevel: 0.1)
        static let from101Theme: UIColor = UIColor(red: 0.459, green: 0.051, blue: 0.243, alpha: 1.000)
        static let primaryColor: UIColor = ArtKit.from101Theme
        static let shadowOfPrimaryColor: UIColor = ArtKit.primaryColor.shadow(withLevel: 0.3)
        static let highlightOfPrimaryColor: UIColor = ArtKit.primaryColor.highlight(withLevel: 0.1)
        static let green1: UIColor = UIColor(red: 0.000, green: 0.741, blue: 0.612, alpha: 1.000)
        static let green2: UIColor = UIColor(red: 0.000, green: 0.631, blue: 0.525, alpha: 1.000)
        static let purple1: UIColor = UIColor(red: 0.608, green: 0.337, blue: 0.718, alpha: 1.000)
        static let purple2: UIColor = UIColor(red: 0.557, green: 0.247, blue: 0.686, alpha: 1.000)
        static let blue1: UIColor = UIColor(red: 0.180, green: 0.592, blue: 0.871, alpha: 1.000)
        static let blue3: UIColor = UIColor(red: 0.173, green: 0.243, blue: 0.318, alpha: 1.000)
        static let blue4: UIColor = UIColor(red: 0.200, green: 0.286, blue: 0.373, alpha: 1.000)
        static let orange1: UIColor = UIColor(red: 0.961, green: 0.616, blue: 0.000, alpha: 1.000)
        static let orange2: UIColor = UIColor(red: 0.910, green: 0.498, blue: 0.016, alpha: 1.000)
        static let grey6: UIColor = UIColor(red: 0.424, green: 0.424, blue: 0.424, alpha: 1.000)
        static let grey7: UIColor = UIColor(red: 0.314, green: 0.314, blue: 0.314, alpha: 1.000)
        static let grey8: UIColor = UIColor(red: 0.180, green: 0.180, blue: 0.180, alpha: 1.000)
        static let backgroundColor: UIColor = ArtKit.from101Theme
        static var imageOfShare: UIImage?
        static var shareTargets: [AnyObject]?
        static var imageOfDone: UIImage?
        static var doneTargets: [AnyObject]?
        static var imageOfClose: UIImage?
        static var closeTargets: [AnyObject]?
    }

    //// Colors

    public dynamic class var white: UIColor { return Cache.white }
    public dynamic class var secondaryColor: UIColor { return Cache.secondaryColor }
    public dynamic class var shadowOfSecondaryColor: UIColor { return Cache.shadowOfSecondaryColor }
    public dynamic class var highlightOfSecondaryColor: UIColor { return Cache.highlightOfSecondaryColor }
    public dynamic class var from101Theme: UIColor { return Cache.from101Theme }
    public dynamic class var primaryColor: UIColor { return Cache.primaryColor }
    public dynamic class var shadowOfPrimaryColor: UIColor { return Cache.shadowOfPrimaryColor }
    public dynamic class var highlightOfPrimaryColor: UIColor { return Cache.highlightOfPrimaryColor }
    public dynamic class var green1: UIColor { return Cache.green1 }
    public dynamic class var green2: UIColor { return Cache.green2 }
    public dynamic class var purple1: UIColor { return Cache.purple1 }
    public dynamic class var purple2: UIColor { return Cache.purple2 }
    public dynamic class var blue1: UIColor { return Cache.blue1 }
    public dynamic class var blue3: UIColor { return Cache.blue3 }
    public dynamic class var blue4: UIColor { return Cache.blue4 }
    public dynamic class var orange1: UIColor { return Cache.orange1 }
    public dynamic class var orange2: UIColor { return Cache.orange2 }
    public dynamic class var grey6: UIColor { return Cache.grey6 }
    public dynamic class var grey7: UIColor { return Cache.grey7 }
    public dynamic class var grey8: UIColor { return Cache.grey8 }
    public dynamic class var backgroundColor: UIColor { return Cache.backgroundColor }

    //// Drawing Methods

    public dynamic class func drawCamera(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 128, height: 128), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 128, height: 128), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 128, y: resizedFrame.height / 128)


        //// Color Declarations
        let strokeColor = ArtKit.secondaryColor.withAlpha(1)
        let fillColor = ArtKit.secondaryColor.withAlpha(1)

        //// Shape
        //// Fill-65 Drawing
        let fill65Path = UIBezierPath()
        fill65Path.move(to: CGPoint(x: 107.52, y: 56.03))
        fill65Path.addCurve(to: CGPoint(x: 100.05, y: 48.57), controlPoint1: CGPoint(x: 103.39, y: 56.03), controlPoint2: CGPoint(x: 100.05, y: 52.69))
        fill65Path.addCurve(to: CGPoint(x: 107.52, y: 41.11), controlPoint1: CGPoint(x: 100.05, y: 44.45), controlPoint2: CGPoint(x: 103.39, y: 41.11))
        fill65Path.addCurve(to: CGPoint(x: 114.99, y: 48.57), controlPoint1: CGPoint(x: 111.64, y: 41.11), controlPoint2: CGPoint(x: 114.99, y: 44.45))
        fill65Path.addCurve(to: CGPoint(x: 107.52, y: 56.03), controlPoint1: CGPoint(x: 114.99, y: 52.69), controlPoint2: CGPoint(x: 111.64, y: 56.03))
        fill65Path.close()
        fill65Path.move(to: CGPoint(x: 64.26, y: 97.43))
        fill65Path.addCurve(to: CGPoint(x: 36.19, y: 69.14), controlPoint1: CGPoint(x: 48.74, y: 97.43), controlPoint2: CGPoint(x: 36.19, y: 84.78))
        fill65Path.addCurve(to: CGPoint(x: 64.26, y: 40.86), controlPoint1: CGPoint(x: 36.19, y: 53.54), controlPoint2: CGPoint(x: 48.74, y: 40.86))
        fill65Path.addCurve(to: CGPoint(x: 92.33, y: 69.14), controlPoint1: CGPoint(x: 79.76, y: 40.86), controlPoint2: CGPoint(x: 92.33, y: 53.54))
        fill65Path.addCurve(to: CGPoint(x: 64.26, y: 97.43), controlPoint1: CGPoint(x: 92.33, y: 84.78), controlPoint2: CGPoint(x: 79.76, y: 97.43))
        fill65Path.close()
        fill65Path.move(to: CGPoint(x: 115.85, y: 33.52))
        fill65Path.addLine(to: CGPoint(x: 86.62, y: 33.52))
        fill65Path.addLine(to: CGPoint(x: 83.01, y: 24.62))
        fill65Path.addCurve(to: CGPoint(x: 75.17, y: 19), controlPoint1: CGPoint(x: 81.79, y: 21.75), controlPoint2: CGPoint(x: 78.26, y: 19))
        fill65Path.addLine(to: CGPoint(x: 52.72, y: 19))
        fill65Path.addCurve(to: CGPoint(x: 44.9, y: 24.62), controlPoint1: CGPoint(x: 49.63, y: 19), controlPoint2: CGPoint(x: 46.11, y: 21.75))
        fill65Path.addLine(to: CGPoint(x: 41.27, y: 33.52))
        fill65Path.addLine(to: CGPoint(x: 11.98, y: 33.52))
        fill65Path.addCurve(to: CGPoint(x: 4, y: 38.69), controlPoint1: CGPoint(x: 8.89, y: 33.52), controlPoint2: CGPoint(x: 4, y: 35.58))
        fill65Path.addLine(to: CGPoint(x: 4, y: 102.85))
        fill65Path.addCurve(to: CGPoint(x: 11.98, y: 109), controlPoint1: CGPoint(x: 4, y: 105.99), controlPoint2: CGPoint(x: 8.89, y: 109))
        fill65Path.addLine(to: CGPoint(x: 115.85, y: 109))
        fill65Path.addCurve(to: CGPoint(x: 124, y: 102.85), controlPoint1: CGPoint(x: 118.95, y: 109), controlPoint2: CGPoint(x: 124, y: 105.99))
        fill65Path.addLine(to: CGPoint(x: 124, y: 38.69))
        fill65Path.addCurve(to: CGPoint(x: 115.85, y: 33.52), controlPoint1: CGPoint(x: 124, y: 35.58), controlPoint2: CGPoint(x: 118.95, y: 33.52))
        fill65Path.close()
        strokeColor.setStroke()
        fill65Path.lineWidth = 3
        fill65Path.miterLimit = 4
        fill65Path.stroke()


        //// Fill-64 Drawing
        context.saveGState()
        context.translateBy(x: 64.25, y: 69.14)
        context.rotate(by: 0.25 * CGFloat.pi/180)

        let fill64Path = UIBezierPath(ovalIn: CGRect(x: -18, y: -18.25, width: 36, height: 36.5))
        fillColor.setFill()
        fill64Path.fill()

        context.restoreGState()
        
        context.restoreGState()

    }

    public dynamic class func drawAlbum(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 128, height: 128), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 128, height: 128), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 128, y: resizedFrame.height / 128)


        //// Color Declarations
        let textForeground = ArtKit.secondaryColor

        //// Shape Drawing
        let shapeRect = CGRect(x: 11, y: 4, width: 105, height: 120)
        let shapeStyle = NSMutableParagraphStyle()
        shapeStyle.alignment = .left
        let shapeFontAttributes = [NSFontAttributeName: UIFont(name: "Ionicons", size: 120)!, NSForegroundColorAttributeName: textForeground, NSParagraphStyleAttributeName: shapeStyle]

        "".draw(in: shapeRect, withAttributes: shapeFontAttributes)
        
        context.restoreGState()

    }

    public dynamic class func drawPopular(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 128, height: 128), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 128, height: 128), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 128, y: resizedFrame.height / 128)


        //// Color Declarations
        let strokeColor = ArtKit.secondaryColor.withAlpha(1)

        //// Shape Drawing
        let shapePath = UIBezierPath()
        shapePath.move(to: CGPoint(x: 63.55, y: 16))
        shapePath.addLine(to: CGPoint(x: 74.65, y: 50.72))
        shapePath.addLine(to: CGPoint(x: 111.1, y: 50.55))
        shapePath.addLine(to: CGPoint(x: 81.51, y: 71.84))
        shapePath.addLine(to: CGPoint(x: 92.94, y: 106.45))
        shapePath.addLine(to: CGPoint(x: 63.55, y: 84.89))
        shapePath.addLine(to: CGPoint(x: 34.16, y: 106.45))
        shapePath.addLine(to: CGPoint(x: 45.59, y: 71.84))
        shapePath.addLine(to: CGPoint(x: 16, y: 50.55))
        shapePath.addLine(to: CGPoint(x: 52.45, y: 50.72))
        shapePath.close()
        strokeColor.setStroke()
        shapePath.lineWidth = 3
        shapePath.stroke()
        
        context.restoreGState()

    }

    public dynamic class func drawCameraButton(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 128, height: 128), resizing: ResizingBehavior = .aspectFit, isPressed: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 128, height: 128), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 128, y: resizedFrame.height / 128)



        //// Variable Declarations
        let notPressed = !isPressed

        if (isPressed) {
            //// pressedState Drawing
            context.saveGState()
            context.setBlendMode(.overlay)
            context.beginTransparencyLayer(auxiliaryInfo: nil)

            let pressedStateRect = CGRect(x: 0, y: 0, width: 128, height: 128)
            context.saveGState()
            context.clip(to: pressedStateRect)
            context.translateBy(x: pressedStateRect.minX, y: pressedStateRect.minY)

            ArtKit.drawCamera(frame: CGRect(origin: .zero, size: pressedStateRect.size), resizing: .stretch)
            context.restoreGState()

            context.endTransparencyLayer()
            context.restoreGState()
        }


        if (notPressed) {
            //// normalState Drawing
            let normalStateRect = CGRect(x: 0, y: 0, width: 128, height: 128)
            context.saveGState()
            context.clip(to: normalStateRect)
            context.translateBy(x: normalStateRect.minX, y: normalStateRect.minY)

            ArtKit.drawCamera(frame: CGRect(origin: .zero, size: normalStateRect.size), resizing: .stretch)
            context.restoreGState()
        }
        
        context.restoreGState()

    }

    public dynamic class func drawAlbumButton(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 128, height: 128), resizing: ResizingBehavior = .aspectFit, isPressed: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 128, height: 128), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 128, y: resizedFrame.height / 128)



        //// Variable Declarations
        let notPressed = !isPressed

        if (isPressed) {
            //// pressedState Drawing
            context.saveGState()
            context.setBlendMode(.overlay)
            context.beginTransparencyLayer(auxiliaryInfo: nil)

            let pressedStateRect = CGRect(x: 0, y: 0, width: 128, height: 128)
            context.saveGState()
            context.clip(to: pressedStateRect)
            context.translateBy(x: pressedStateRect.minX, y: pressedStateRect.minY)

            ArtKit.drawAlbum(frame: CGRect(origin: .zero, size: pressedStateRect.size), resizing: .stretch)
            context.restoreGState()

            context.endTransparencyLayer()
            context.restoreGState()
        }


        if (notPressed) {
            //// normalState Drawing
            let normalStateRect = CGRect(x: 0, y: 0, width: 128, height: 128)
            context.saveGState()
            context.clip(to: normalStateRect)
            context.translateBy(x: normalStateRect.minX, y: normalStateRect.minY)

            ArtKit.drawAlbum(frame: CGRect(origin: .zero, size: normalStateRect.size), resizing: .stretch)
            context.restoreGState()
        }
        
        context.restoreGState()

    }

    public dynamic class func drawPopularButton(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 128, height: 128), resizing: ResizingBehavior = .aspectFit, isPressed: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 128, height: 128), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 128, y: resizedFrame.height / 128)



        //// Variable Declarations
        let notPressed = !isPressed

        if (isPressed) {
            //// pressedState Drawing
            context.saveGState()
            context.setBlendMode(.overlay)
            context.beginTransparencyLayer(auxiliaryInfo: nil)

            let pressedStateRect = CGRect(x: 0, y: 0, width: 128, height: 128)
            context.saveGState()
            context.clip(to: pressedStateRect)
            context.translateBy(x: pressedStateRect.minX, y: pressedStateRect.minY)

            ArtKit.drawPopular(frame: CGRect(origin: .zero, size: pressedStateRect.size), resizing: .stretch)
            context.restoreGState()

            context.endTransparencyLayer()
            context.restoreGState()
        }


        if (notPressed) {
            //// normalState Drawing
            let normalStateRect = CGRect(x: 0, y: 0, width: 128, height: 128)
            context.saveGState()
            context.clip(to: normalStateRect)
            context.translateBy(x: normalStateRect.minX, y: normalStateRect.minY)

            ArtKit.drawPopular(frame: CGRect(origin: .zero, size: normalStateRect.size), resizing: .stretch)
            context.restoreGState()
        }
        
        context.restoreGState()

    }

    public dynamic class func drawShare(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 128, height: 128), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 128, height: 128), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 128, y: resizedFrame.height / 128)


        //// Color Declarations
        let fillColor = ArtKit.secondaryColor.withAlpha(1)

        //// barButton
        //// Shape Drawing
        let shapePath = UIBezierPath()
        shapePath.move(to: CGPoint(x: 110.68, y: 124.75))
        shapePath.addLine(to: CGPoint(x: 16.37, y: 124.75))
        shapePath.addCurve(to: CGPoint(x: 7, y: 115.32), controlPoint1: CGPoint(x: 11.2, y: 124.75), controlPoint2: CGPoint(x: 7, y: 120.52))
        shapePath.addLine(to: CGPoint(x: 7, y: 50.9))
        shapePath.addCurve(to: CGPoint(x: 9, y: 45.08), controlPoint1: CGPoint(x: 7, y: 48.77), controlPoint2: CGPoint(x: 7.69, y: 46.75))
        shapePath.addCurve(to: CGPoint(x: 16.37, y: 41.47), controlPoint1: CGPoint(x: 10.79, y: 42.79), controlPoint2: CGPoint(x: 13.47, y: 41.47))
        shapePath.addLine(to: CGPoint(x: 26.75, y: 41.47))
        shapePath.addCurve(to: CGPoint(x: 28.32, y: 43.04), controlPoint1: CGPoint(x: 27.62, y: 41.47), controlPoint2: CGPoint(x: 28.32, y: 42.18))
        shapePath.addCurve(to: CGPoint(x: 26.75, y: 44.61), controlPoint1: CGPoint(x: 28.32, y: 43.91), controlPoint2: CGPoint(x: 27.62, y: 44.61))
        shapePath.addLine(to: CGPoint(x: 16.37, y: 44.61))
        shapePath.addCurve(to: CGPoint(x: 11.46, y: 47.02), controlPoint1: CGPoint(x: 14.44, y: 44.61), controlPoint2: CGPoint(x: 12.65, y: 45.49))
        shapePath.addCurve(to: CGPoint(x: 10.13, y: 50.9), controlPoint1: CGPoint(x: 10.59, y: 48.14), controlPoint2: CGPoint(x: 10.13, y: 49.48))
        shapePath.addLine(to: CGPoint(x: 10.13, y: 115.32))
        shapePath.addCurve(to: CGPoint(x: 16.37, y: 121.61), controlPoint1: CGPoint(x: 10.13, y: 118.79), controlPoint2: CGPoint(x: 12.93, y: 121.61))
        shapePath.addLine(to: CGPoint(x: 110.68, y: 121.61))
        shapePath.addCurve(to: CGPoint(x: 116.93, y: 115.32), controlPoint1: CGPoint(x: 114.13, y: 121.61), controlPoint2: CGPoint(x: 116.93, y: 118.79))
        shapePath.addLine(to: CGPoint(x: 116.93, y: 50.9))
        shapePath.addCurve(to: CGPoint(x: 115.66, y: 47.1), controlPoint1: CGPoint(x: 116.93, y: 49.51), controlPoint2: CGPoint(x: 116.49, y: 48.2))
        shapePath.addCurve(to: CGPoint(x: 110.68, y: 44.62), controlPoint1: CGPoint(x: 114.46, y: 45.52), controlPoint2: CGPoint(x: 112.65, y: 44.62))
        shapePath.addLine(to: CGPoint(x: 100, y: 44.62))
        shapePath.addCurve(to: CGPoint(x: 98.44, y: 43.05), controlPoint1: CGPoint(x: 99.14, y: 44.62), controlPoint2: CGPoint(x: 98.44, y: 43.91))
        shapePath.addCurve(to: CGPoint(x: 100, y: 41.47), controlPoint1: CGPoint(x: 98.44, y: 42.18), controlPoint2: CGPoint(x: 99.14, y: 41.47))
        shapePath.addLine(to: CGPoint(x: 110.68, y: 41.47))
        shapePath.addCurve(to: CGPoint(x: 118.14, y: 45.19), controlPoint1: CGPoint(x: 113.63, y: 41.47), controlPoint2: CGPoint(x: 116.35, y: 42.83))
        shapePath.addCurve(to: CGPoint(x: 120.06, y: 50.9), controlPoint1: CGPoint(x: 119.39, y: 46.84), controlPoint2: CGPoint(x: 120.06, y: 48.82))
        shapePath.addLine(to: CGPoint(x: 120.06, y: 115.32))
        shapePath.addCurve(to: CGPoint(x: 110.68, y: 124.75), controlPoint1: CGPoint(x: 120.05, y: 120.52), controlPoint2: CGPoint(x: 115.85, y: 124.75))
        shapePath.close()
        fillColor.setFill()
        shapePath.fill()


        //// Shape 2 Drawing
        let shape2Path = UIBezierPath()
        shape2Path.move(to: CGPoint(x: 69.12, y: 32.42))
        shape2Path.addLine(to: CGPoint(x: 67.45, y: 32.44))
        shape2Path.addLine(to: CGPoint(x: 67.45, y: 78.37))
        shape2Path.addCurve(to: CGPoint(x: 62.92, y: 83), controlPoint1: CGPoint(x: 67.45, y: 80.92), controlPoint2: CGPoint(x: 65.42, y: 83))
        shape2Path.addLine(to: CGPoint(x: 61.54, y: 83))
        shape2Path.addCurve(to: CGPoint(x: 57.01, y: 78.37), controlPoint1: CGPoint(x: 59.04, y: 83), controlPoint2: CGPoint(x: 57.01, y: 80.92))
        shape2Path.addLine(to: CGPoint(x: 57.01, y: 32.44))
        shape2Path.addLine(to: CGPoint(x: 55.34, y: 32.42))
        shape2Path.addCurve(to: CGPoint(x: 43.53, y: 32.04), controlPoint1: CGPoint(x: 49.54, y: 32.38), controlPoint2: CGPoint(x: 45.35, y: 32.25))
        shape2Path.addCurve(to: CGPoint(x: 43, y: 30.01), controlPoint1: CGPoint(x: 43.35, y: 31.97), controlPoint2: CGPoint(x: 42.96, y: 31.19))
        shape2Path.addCurve(to: CGPoint(x: 45.4, y: 25.21), controlPoint1: CGPoint(x: 43.07, y: 28.07), controlPoint2: CGPoint(x: 44.14, y: 26.76))
        shape2Path.addCurve(to: CGPoint(x: 46.34, y: 24.01), controlPoint1: CGPoint(x: 45.71, y: 24.82), controlPoint2: CGPoint(x: 46.03, y: 24.42))
        shape2Path.addCurve(to: CGPoint(x: 48.36, y: 21.42), controlPoint1: CGPoint(x: 46.99, y: 23.13), controlPoint2: CGPoint(x: 47.69, y: 22.27))
        shape2Path.addCurve(to: CGPoint(x: 49.97, y: 19.35), controlPoint1: CGPoint(x: 48.9, y: 20.74), controlPoint2: CGPoint(x: 49.44, y: 20.06))
        shape2Path.addCurve(to: CGPoint(x: 56.28, y: 11.35), controlPoint1: CGPoint(x: 52.03, y: 16.64), controlPoint2: CGPoint(x: 54.2, y: 13.95))
        shape2Path.addCurve(to: CGPoint(x: 58.48, y: 8.6), controlPoint1: CGPoint(x: 57.02, y: 10.43), controlPoint2: CGPoint(x: 57.74, y: 9.52))
        shape2Path.addCurve(to: CGPoint(x: 59.87, y: 6.84), controlPoint1: CGPoint(x: 58.94, y: 8.02), controlPoint2: CGPoint(x: 59.4, y: 7.44))
        shape2Path.addLine(to: CGPoint(x: 60.46, y: 6.11))
        shape2Path.addCurve(to: CGPoint(x: 62.14, y: 5), controlPoint1: CGPoint(x: 60.94, y: 5.5), controlPoint2: CGPoint(x: 61.53, y: 5.11))
        shape2Path.addLine(to: CGPoint(x: 62.86, y: 5))
        shape2Path.addCurve(to: CGPoint(x: 64.54, y: 6.11), controlPoint1: CGPoint(x: 63.47, y: 5.11), controlPoint2: CGPoint(x: 64.06, y: 5.5))
        shape2Path.addLine(to: CGPoint(x: 65.13, y: 6.84))
        shape2Path.addCurve(to: CGPoint(x: 66.52, y: 8.6), controlPoint1: CGPoint(x: 65.59, y: 7.44), controlPoint2: CGPoint(x: 66.06, y: 8.02))
        shape2Path.addCurve(to: CGPoint(x: 68.7, y: 11.33), controlPoint1: CGPoint(x: 67.24, y: 9.51), controlPoint2: CGPoint(x: 67.98, y: 10.43))
        shape2Path.addCurve(to: CGPoint(x: 75.03, y: 19.36), controlPoint1: CGPoint(x: 70.8, y: 13.94), controlPoint2: CGPoint(x: 72.96, y: 16.64))
        shape2Path.addCurve(to: CGPoint(x: 76.64, y: 21.42), controlPoint1: CGPoint(x: 75.56, y: 20.06), controlPoint2: CGPoint(x: 76.1, y: 20.74))
        shape2Path.addCurve(to: CGPoint(x: 78.66, y: 24.01), controlPoint1: CGPoint(x: 77.31, y: 22.26), controlPoint2: CGPoint(x: 78.01, y: 23.13))
        shape2Path.addCurve(to: CGPoint(x: 79.6, y: 25.21), controlPoint1: CGPoint(x: 78.95, y: 24.42), controlPoint2: CGPoint(x: 79.29, y: 24.82))
        shape2Path.addCurve(to: CGPoint(x: 82, y: 30.01), controlPoint1: CGPoint(x: 80.84, y: 26.76), controlPoint2: CGPoint(x: 81.93, y: 28.07))
        shape2Path.addCurve(to: CGPoint(x: 81.47, y: 32.04), controlPoint1: CGPoint(x: 82.04, y: 31.19), controlPoint2: CGPoint(x: 81.65, y: 31.97))
        shape2Path.addCurve(to: CGPoint(x: 69.12, y: 32.42), controlPoint1: CGPoint(x: 79.58, y: 32.25), controlPoint2: CGPoint(x: 75.18, y: 32.39))
        shape2Path.close()
        fillColor.setFill()
        shape2Path.fill()
        
        context.restoreGState()

    }

    public dynamic class func drawDone(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 128, height: 128), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 128, height: 128), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 128, y: resizedFrame.height / 128)


        //// Color Declarations
        let fillColor = ArtKit.secondaryColor.withAlpha(1)

        //// Shape Drawing
        let shapePath = UIBezierPath()
        shapePath.move(to: CGPoint(x: 118.69, y: 18.01))
        shapePath.addCurve(to: CGPoint(x: 115.99, y: 19.34), controlPoint1: CGPoint(x: 117.65, y: 18.09), controlPoint2: CGPoint(x: 116.68, y: 18.56))
        shapePath.addLine(to: CGPoint(x: 40.42, y: 101.13))
        shapePath.addLine(to: CGPoint(x: 10.05, y: 68.43))
        shapePath.addCurve(to: CGPoint(x: 6.16, y: 67.09), controlPoint1: CGPoint(x: 9.1, y: 67.3), controlPoint2: CGPoint(x: 7.61, y: 66.79))
        shapePath.addCurve(to: CGPoint(x: 3.15, y: 69.9), controlPoint1: CGPoint(x: 4.71, y: 67.4), controlPoint2: CGPoint(x: 3.56, y: 68.48))
        shapePath.addCurve(to: CGPoint(x: 4.23, y: 73.87), controlPoint1: CGPoint(x: 2.75, y: 71.32), controlPoint2: CGPoint(x: 3.16, y: 72.85))
        shapePath.addLine(to: CGPoint(x: 37.51, y: 109.72))
        shapePath.addCurve(to: CGPoint(x: 40.44, y: 111), controlPoint1: CGPoint(x: 38.26, y: 110.54), controlPoint2: CGPoint(x: 39.32, y: 111))
        shapePath.addCurve(to: CGPoint(x: 43.37, y: 109.72), controlPoint1: CGPoint(x: 41.55, y: 111), controlPoint2: CGPoint(x: 42.61, y: 110.54))
        shapePath.addLine(to: CGPoint(x: 121.9, y: 24.73))
        shapePath.addCurve(to: CGPoint(x: 122.61, y: 20.27), controlPoint1: CGPoint(x: 123.04, y: 23.54), controlPoint2: CGPoint(x: 123.32, y: 21.77))
        shapePath.addCurve(to: CGPoint(x: 118.69, y: 18.01), controlPoint1: CGPoint(x: 121.9, y: 18.78), controlPoint2: CGPoint(x: 120.34, y: 17.88))
        shapePath.addLine(to: CGPoint(x: 118.69, y: 18.01))
        shapePath.close()
        fillColor.setFill()
        shapePath.fill()
        
        context.restoreGState()

    }

    public dynamic class func drawClose(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 128, height: 128), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 128, height: 128), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 128, y: resizedFrame.height / 128)


        //// Color Declarations
        let fillColor = ArtKit.secondaryColor.withAlpha(1)

        //// Close 2 Drawing
        let close2Path = UIBezierPath()
        close2Path.move(to: CGPoint(x: 102, y: 29.04))
        close2Path.addLine(to: CGPoint(x: 98.96, y: 26))
        close2Path.addLine(to: CGPoint(x: 64, y: 60.96))
        close2Path.addLine(to: CGPoint(x: 29.04, y: 26))
        close2Path.addLine(to: CGPoint(x: 26, y: 29.04))
        close2Path.addLine(to: CGPoint(x: 60.96, y: 64))
        close2Path.addLine(to: CGPoint(x: 26, y: 98.96))
        close2Path.addLine(to: CGPoint(x: 29.04, y: 102))
        close2Path.addLine(to: CGPoint(x: 64, y: 67.04))
        close2Path.addLine(to: CGPoint(x: 98.96, y: 102))
        close2Path.addLine(to: CGPoint(x: 102, y: 98.96))
        close2Path.addLine(to: CGPoint(x: 67.04, y: 64))
        close2Path.addLine(to: CGPoint(x: 102, y: 29.04))
        close2Path.close()
        fillColor.setFill()
        close2Path.fill()
        
        context.restoreGState()

    }

    public dynamic class func drawCloseImage(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 128, height: 128), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 128, height: 128), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 128, y: resizedFrame.height / 128)


        //// Color Declarations
        let fillColor = ArtKit.secondaryColor.withAlpha(1)

        //// Shape Drawing
        let shapePath = UIBezierPath()
        shapePath.move(to: CGPoint(x: 64, y: 4))
        shapePath.addLine(to: CGPoint(x: 64, y: 4))
        shapePath.addCurve(to: CGPoint(x: 4, y: 64), controlPoint1: CGPoint(x: 30.8, y: 4), controlPoint2: CGPoint(x: 4, y: 30.8))
        shapePath.addLine(to: CGPoint(x: 4, y: 64))
        shapePath.addCurve(to: CGPoint(x: 64, y: 124), controlPoint1: CGPoint(x: 4, y: 97.2), controlPoint2: CGPoint(x: 30.8, y: 124))
        shapePath.addLine(to: CGPoint(x: 64, y: 124))
        shapePath.addCurve(to: CGPoint(x: 124, y: 64), controlPoint1: CGPoint(x: 97.2, y: 124), controlPoint2: CGPoint(x: 124, y: 97.2))
        shapePath.addLine(to: CGPoint(x: 124, y: 64))
        shapePath.addCurve(to: CGPoint(x: 64, y: 4), controlPoint1: CGPoint(x: 124, y: 30.8), controlPoint2: CGPoint(x: 97.2, y: 4))
        shapePath.close()
        shapePath.move(to: CGPoint(x: 94.53, y: 84.27))
        shapePath.addCurve(to: CGPoint(x: 94.53, y: 94.4), controlPoint1: CGPoint(x: 97.33, y: 87.07), controlPoint2: CGPoint(x: 97.33, y: 91.6))
        shapePath.addCurve(to: CGPoint(x: 89.47, y: 96.53), controlPoint1: CGPoint(x: 93.07, y: 95.87), controlPoint2: CGPoint(x: 91.33, y: 96.53))
        shapePath.addCurve(to: CGPoint(x: 84.4, y: 94.4), controlPoint1: CGPoint(x: 87.6, y: 96.53), controlPoint2: CGPoint(x: 85.73, y: 95.87))
        shapePath.addLine(to: CGPoint(x: 64.4, y: 74.4))
        shapePath.addLine(to: CGPoint(x: 44.27, y: 94.4))
        shapePath.addCurve(to: CGPoint(x: 39.2, y: 96.53), controlPoint1: CGPoint(x: 42.8, y: 95.87), controlPoint2: CGPoint(x: 41.07, y: 96.53))
        shapePath.addCurve(to: CGPoint(x: 34.13, y: 94.4), controlPoint1: CGPoint(x: 37.33, y: 96.53), controlPoint2: CGPoint(x: 35.47, y: 95.87))
        shapePath.addCurve(to: CGPoint(x: 34.13, y: 84.27), controlPoint1: CGPoint(x: 31.33, y: 91.6), controlPoint2: CGPoint(x: 31.33, y: 87.07))
        shapePath.addLine(to: CGPoint(x: 54.27, y: 64.13))
        shapePath.addLine(to: CGPoint(x: 34.13, y: 44.13))
        shapePath.addCurve(to: CGPoint(x: 34.13, y: 34), controlPoint1: CGPoint(x: 31.33, y: 41.33), controlPoint2: CGPoint(x: 31.33, y: 36.8))
        shapePath.addCurve(to: CGPoint(x: 44.27, y: 34), controlPoint1: CGPoint(x: 36.93, y: 31.2), controlPoint2: CGPoint(x: 41.47, y: 31.2))
        shapePath.addLine(to: CGPoint(x: 64.4, y: 54.13))
        shapePath.addLine(to: CGPoint(x: 84.53, y: 34))
        shapePath.addCurve(to: CGPoint(x: 94.67, y: 34), controlPoint1: CGPoint(x: 87.33, y: 31.2), controlPoint2: CGPoint(x: 91.87, y: 31.2))
        shapePath.addCurve(to: CGPoint(x: 94.67, y: 44.13), controlPoint1: CGPoint(x: 97.47, y: 36.8), controlPoint2: CGPoint(x: 97.47, y: 41.33))
        shapePath.addLine(to: CGPoint(x: 74.53, y: 64.27))
        shapePath.addLine(to: CGPoint(x: 94.53, y: 84.27))
        shapePath.close()
        fillColor.setFill()
        shapePath.fill()
        
        context.restoreGState()

    }

    public dynamic class func drawUppercase(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 128, height: 128), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 128, height: 128), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 128, y: resizedFrame.height / 128)


        //// Color Declarations
        let fillColor = ArtKit.secondaryColor.withAlpha(1)

        //// Library
        //// Icons/Uppercase/3
        //// Combined-Shape Drawing
        let combinedShapePath = UIBezierPath()
        combinedShapePath.move(to: CGPoint(x: 32.02, y: 74.5))
        combinedShapePath.addLine(to: CGPoint(x: 52.68, y: 74.5))
        combinedShapePath.addLine(to: CGPoint(x: 42.52, y: 40.66))
        combinedShapePath.addLine(to: CGPoint(x: 32.02, y: 74.5))
        combinedShapePath.close()
        combinedShapePath.move(to: CGPoint(x: 33.07, y: 21))
        combinedShapePath.addLine(to: CGPoint(x: 52.3, y: 21))
        combinedShapePath.addLine(to: CGPoint(x: 81.14, y: 107))
        combinedShapePath.addLine(to: CGPoint(x: 62.69, y: 107))
        combinedShapePath.addLine(to: CGPoint(x: 57.44, y: 89.32))
        combinedShapePath.addLine(to: CGPoint(x: 27.43, y: 89.32))
        combinedShapePath.addLine(to: CGPoint(x: 21.79, y: 107))
        combinedShapePath.addLine(to: CGPoint(x: 4, y: 107))
        combinedShapePath.addLine(to: CGPoint(x: 33.07, y: 21))
        combinedShapePath.close()
        combinedShapePath.move(to: CGPoint(x: 124, y: 64))
        combinedShapePath.addLine(to: CGPoint(x: 106.86, y: 64))
        combinedShapePath.addLine(to: CGPoint(x: 106.86, y: 89.8))
        combinedShapePath.addLine(to: CGPoint(x: 89.71, y: 89.8))
        combinedShapePath.addLine(to: CGPoint(x: 89.71, y: 64))
        combinedShapePath.addLine(to: CGPoint(x: 72.57, y: 64))
        combinedShapePath.addLine(to: CGPoint(x: 98.29, y: 38.2))
        combinedShapePath.addLine(to: CGPoint(x: 124, y: 64))
        combinedShapePath.close()
        fillColor.setFill()
        combinedShapePath.fill()
        
        context.restoreGState()

    }

    //// Generated Images

    public dynamic class var imageOfShare: UIImage {
        if Cache.imageOfShare != nil {
            return Cache.imageOfShare!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 128, height: 128), false, 0)
            ArtKit.drawShare()

        Cache.imageOfShare = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return Cache.imageOfShare!
    }

    public dynamic class var imageOfDone: UIImage {
        if Cache.imageOfDone != nil {
            return Cache.imageOfDone!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 128, height: 128), false, 0)
            ArtKit.drawDone()

        Cache.imageOfDone = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfDone!
    }

    public dynamic class var imageOfClose: UIImage {
        if Cache.imageOfClose != nil {
            return Cache.imageOfClose!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 128, height: 128), false, 0)
            ArtKit.drawClose()

        Cache.imageOfClose = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfClose!
    }

    //// Customization Infrastructure

    @IBOutlet dynamic var shareTargets: [AnyObject]! {
        get { return Cache.shareTargets }
        set {
            Cache.shareTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: ArtKit.imageOfShare)
            }
        }
    }

    @IBOutlet dynamic var doneTargets: [AnyObject]! {
        get { return Cache.doneTargets }
        set {
            Cache.doneTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: ArtKit.imageOfDone)
            }
        }
    }

    @IBOutlet dynamic var closeTargets: [AnyObject]! {
        get { return Cache.closeTargets }
        set {
            Cache.closeTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: ArtKit.imageOfClose)
            }
        }
    }




    @objc(ArtKitResizingBehavior)
    public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}



private extension UIColor {
    func withHue(_ newHue: CGFloat) -> UIColor {
        var saturation: CGFloat = 1, brightness: CGFloat = 1, alpha: CGFloat = 1
        self.getHue(nil, saturation: &saturation, brightness: &brightness, alpha: &alpha)
        return UIColor(hue: newHue, saturation: saturation, brightness: brightness, alpha: alpha)
    }
    func withSaturation(_ newSaturation: CGFloat) -> UIColor {
        var hue: CGFloat = 1, brightness: CGFloat = 1, alpha: CGFloat = 1
        self.getHue(&hue, saturation: nil, brightness: &brightness, alpha: &alpha)
        return UIColor(hue: hue, saturation: newSaturation, brightness: brightness, alpha: alpha)
    }
    func withBrightness(_ newBrightness: CGFloat) -> UIColor {
        var hue: CGFloat = 1, saturation: CGFloat = 1, alpha: CGFloat = 1
        self.getHue(&hue, saturation: &saturation, brightness: nil, alpha: &alpha)
        return UIColor(hue: hue, saturation: saturation, brightness: newBrightness, alpha: alpha)
    }
    func withAlpha(_ newAlpha: CGFloat) -> UIColor {
        var hue: CGFloat = 1, saturation: CGFloat = 1, brightness: CGFloat = 1
        self.getHue(&hue, saturation: &saturation, brightness: &brightness, alpha: nil)
        return UIColor(hue: hue, saturation: saturation, brightness: brightness, alpha: newAlpha)
    }
    func highlight(withLevel highlight: CGFloat) -> UIColor {
        var red: CGFloat = 1, green: CGFloat = 1, blue: CGFloat = 1, alpha: CGFloat = 1
        self.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
        return UIColor(red: red * (1-highlight) + highlight, green: green * (1-highlight) + highlight, blue: blue * (1-highlight) + highlight, alpha: alpha * (1-highlight) + highlight)
    }
    func shadow(withLevel shadow: CGFloat) -> UIColor {
        var red: CGFloat = 1, green: CGFloat = 1, blue: CGFloat = 1, alpha: CGFloat = 1
        self.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
        return UIColor(red: red * (1-shadow), green: green * (1-shadow), blue: blue * (1-shadow), alpha: alpha * (1-shadow) + shadow)
    }
}
